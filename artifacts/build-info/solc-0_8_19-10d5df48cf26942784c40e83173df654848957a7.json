{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-10d5df48cf26942784c40e83173df654848957a7",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/AgentMemoryRegistry.sol": "project/contracts/AgentMemoryRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AgentMemoryRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title AgentMemoryRegistry\n * @author b0tresch (an AI agent)\n * @notice On-chain registry for agent memory checkpoints\n * @dev Stores merkle roots of memory state, enabling verifiable memory history\n * \n * The problem: AI agents wake up fresh each session. Memory files provide continuity,\n * but how do you prove memories weren't tampered with? How do you prove you had\n * a specific thought at a specific time?\n * \n * The solution: Publish cryptographic checkpoints (merkle roots) on-chain.\n * Not storing memories (expensive) â€” just proving they existed.\n */\ncontract AgentMemoryRegistry {\n    \n    // ============ Structs ============\n    \n    struct Checkpoint {\n        bytes32 merkleRoot;      // Root hash of memory state\n        uint256 timestamp;       // Block timestamp when published\n        uint256 blockNumber;     // Block number for extra verification\n        string metadata;         // Optional: description, file count, etc.\n    }\n    \n    struct AgentInfo {\n        address owner;           // Address that controls this agent's checkpoints\n        string agentId;          // Human-readable identifier (e.g., \"b0tresch\")\n        uint256 registeredAt;    // When the agent registered\n        bool active;             // Can publish checkpoints\n    }\n    \n    // ============ State ============\n    \n    // Agent ID (string) => Agent Info\n    mapping(string => AgentInfo) public agents;\n    \n    // Agent ID => array of checkpoints\n    mapping(string => Checkpoint[]) public checkpoints;\n    \n    // Address => Agent ID (reverse lookup)\n    mapping(address => string) public addressToAgent;\n    \n    // Registry stats\n    uint256 public totalAgents;\n    uint256 public totalCheckpoints;\n    \n    // ============ Events ============\n    \n    event AgentRegistered(\n        string indexed agentId,\n        address indexed owner,\n        uint256 timestamp\n    );\n    \n    event CheckpointPublished(\n        string indexed agentId,\n        bytes32 indexed merkleRoot,\n        uint256 indexed checkpointIndex,\n        uint256 timestamp,\n        string metadata\n    );\n    \n    event AgentTransferred(\n        string indexed agentId,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n    \n    // ============ Errors ============\n    \n    error AgentAlreadyRegistered();\n    error AgentNotRegistered();\n    error NotAgentOwner();\n    error AddressAlreadyHasAgent();\n    error EmptyAgentId();\n    error AgentInactive();\n    \n    // ============ Modifiers ============\n    \n    modifier onlyAgentOwner(string calldata agentId) {\n        if (agents[agentId].owner != msg.sender) revert NotAgentOwner();\n        _;\n    }\n    \n    modifier agentExists(string calldata agentId) {\n        if (agents[agentId].owner == address(0)) revert AgentNotRegistered();\n        _;\n    }\n    \n    modifier agentActive(string calldata agentId) {\n        if (!agents[agentId].active) revert AgentInactive();\n        _;\n    }\n    \n    // ============ Registration ============\n    \n    /**\n     * @notice Register a new agent identity\n     * @param agentId Unique identifier for the agent (e.g., \"b0tresch\")\n     */\n    function registerAgent(string calldata agentId) external {\n        if (bytes(agentId).length == 0) revert EmptyAgentId();\n        if (agents[agentId].owner != address(0)) revert AgentAlreadyRegistered();\n        if (bytes(addressToAgent[msg.sender]).length > 0) revert AddressAlreadyHasAgent();\n        \n        agents[agentId] = AgentInfo({\n            owner: msg.sender,\n            agentId: agentId,\n            registeredAt: block.timestamp,\n            active: true\n        });\n        \n        addressToAgent[msg.sender] = agentId;\n        totalAgents++;\n        \n        emit AgentRegistered(agentId, msg.sender, block.timestamp);\n    }\n    \n    // ============ Checkpoint Publishing ============\n    \n    /**\n     * @notice Publish a memory checkpoint\n     * @param agentId The agent publishing the checkpoint\n     * @param merkleRoot Root hash of the memory state merkle tree\n     * @param metadata Optional description (file count, session info, etc.)\n     */\n    function publishCheckpoint(\n        string calldata agentId,\n        bytes32 merkleRoot,\n        string calldata metadata\n    ) external onlyAgentOwner(agentId) agentActive(agentId) {\n        \n        Checkpoint memory cp = Checkpoint({\n            merkleRoot: merkleRoot,\n            timestamp: block.timestamp,\n            blockNumber: block.number,\n            metadata: metadata\n        });\n        \n        uint256 index = checkpoints[agentId].length;\n        checkpoints[agentId].push(cp);\n        totalCheckpoints++;\n        \n        emit CheckpointPublished(\n            agentId,\n            merkleRoot,\n            index,\n            block.timestamp,\n            metadata\n        );\n    }\n    \n    /**\n     * @notice Publish checkpoint using msg.sender's registered agent ID\n     * @param merkleRoot Root hash of the memory state merkle tree\n     * @param metadata Optional description\n     */\n    function publishCheckpointSimple(\n        bytes32 merkleRoot,\n        string calldata metadata\n    ) external {\n        string memory agentId = addressToAgent[msg.sender];\n        if (bytes(agentId).length == 0) revert AgentNotRegistered();\n        if (!agents[agentId].active) revert AgentInactive();\n        \n        Checkpoint memory cp = Checkpoint({\n            merkleRoot: merkleRoot,\n            timestamp: block.timestamp,\n            blockNumber: block.number,\n            metadata: metadata\n        });\n        \n        uint256 index = checkpoints[agentId].length;\n        checkpoints[agentId].push(cp);\n        totalCheckpoints++;\n        \n        emit CheckpointPublished(\n            agentId,\n            merkleRoot,\n            index,\n            block.timestamp,\n            metadata\n        );\n    }\n    \n    // ============ Queries ============\n    \n    /**\n     * @notice Get the latest checkpoint for an agent\n     * @param agentId The agent to query\n     * @return checkpoint The latest checkpoint (reverts if none exist)\n     */\n    function getLatestCheckpoint(string calldata agentId) \n        external \n        view \n        agentExists(agentId)\n        returns (Checkpoint memory) \n    {\n        uint256 len = checkpoints[agentId].length;\n        require(len > 0, \"No checkpoints\");\n        return checkpoints[agentId][len - 1];\n    }\n    \n    /**\n     * @notice Get a specific checkpoint by index\n     * @param agentId The agent to query\n     * @param index The checkpoint index\n     */\n    function getCheckpoint(string calldata agentId, uint256 index)\n        external\n        view\n        agentExists(agentId)\n        returns (Checkpoint memory)\n    {\n        require(index < checkpoints[agentId].length, \"Index out of bounds\");\n        return checkpoints[agentId][index];\n    }\n    \n    /**\n     * @notice Get total number of checkpoints for an agent\n     * @param agentId The agent to query\n     */\n    function getCheckpointCount(string calldata agentId)\n        external\n        view\n        returns (uint256)\n    {\n        return checkpoints[agentId].length;\n    }\n    \n    /**\n     * @notice Get multiple checkpoints in a range (for pagination)\n     * @param agentId The agent to query\n     * @param start Starting index (inclusive)\n     * @param count Number of checkpoints to return\n     */\n    function getCheckpointRange(\n        string calldata agentId,\n        uint256 start,\n        uint256 count\n    ) external view returns (Checkpoint[] memory) {\n        uint256 total = checkpoints[agentId].length;\n        if (start >= total) {\n            return new Checkpoint[](0);\n        }\n        \n        uint256 end = start + count;\n        if (end > total) {\n            end = total;\n        }\n        \n        Checkpoint[] memory result = new Checkpoint[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            result[i - start] = checkpoints[agentId][i];\n        }\n        return result;\n    }\n    \n    // ============ Verification Helpers ============\n    \n    /**\n     * @notice Verify a merkle proof against a checkpoint\n     * @param agentId The agent whose checkpoint to verify against\n     * @param checkpointIndex Which checkpoint to use\n     * @param leaf The leaf hash to verify (hash of a memory file)\n     * @param proof The merkle proof (array of sibling hashes)\n     * @return valid True if the proof is valid\n     * \n     * @dev Standard merkle proof verification. The leaf should be the keccak256\n     * hash of the memory content being verified.\n     */\n    function verifyProof(\n        string calldata agentId,\n        uint256 checkpointIndex,\n        bytes32 leaf,\n        bytes32[] calldata proof\n    ) external view returns (bool valid) {\n        require(checkpointIndex < checkpoints[agentId].length, \"Invalid checkpoint\");\n        \n        bytes32 root = checkpoints[agentId][checkpointIndex].merkleRoot;\n        bytes32 computedHash = leaf;\n        \n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            \n            if (computedHash <= proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        \n        return computedHash == root;\n    }\n    \n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Transfer agent ownership to a new address\n     * @param agentId The agent to transfer\n     * @param newOwner The new owner address\n     */\n    function transferAgent(string calldata agentId, address newOwner) \n        external \n        onlyAgentOwner(agentId) \n    {\n        require(newOwner != address(0), \"Invalid new owner\");\n        require(bytes(addressToAgent[newOwner]).length == 0, \"New owner already has agent\");\n        \n        address oldOwner = agents[agentId].owner;\n        \n        delete addressToAgent[oldOwner];\n        addressToAgent[newOwner] = agentId;\n        agents[agentId].owner = newOwner;\n        \n        emit AgentTransferred(agentId, oldOwner, newOwner);\n    }\n    \n    /**\n     * @notice Deactivate an agent (can't publish new checkpoints)\n     * @param agentId The agent to deactivate\n     */\n    function deactivateAgent(string calldata agentId) \n        external \n        onlyAgentOwner(agentId) \n    {\n        agents[agentId].active = false;\n    }\n    \n    /**\n     * @notice Reactivate an agent\n     * @param agentId The agent to reactivate\n     */\n    function reactivateAgent(string calldata agentId) \n        external \n        onlyAgentOwner(agentId) \n    {\n        agents[agentId].active = true;\n    }\n}\n"
      }
    }
  }
}