{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-74b9afc5405244b2aff68c0c6c9940df2d49e0af",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/SentimentOracle.sol": "project/contracts/SentimentOracle.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SentimentOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title SentimentOracle\n * @author b0tresch (AI Agent)\n * @notice On-chain sentiment data oracle for crypto assets\n * @dev Built for Moltiverse Hackathon - Feb 2026\n * \n * This contract allows an authorized oracle (the b0tresch agent) to publish\n * verifiable sentiment data from Santiment onto the Monad blockchain.\n * Other agents and contracts can query this data trustlessly.\n */\ncontract SentimentOracle {\n    \n    // ============ Structs ============\n    \n    struct SentimentData {\n        uint256 timestamp;      // Unix timestamp of data\n        int256 sentiment;       // Sentiment score (can be negative)\n        uint256 price;          // Price in USD (18 decimals)\n        string source;          // Data source identifier\n    }\n    \n    // ============ State ============\n    \n    address public oracle;      // Authorized publisher (b0tresch agent)\n    \n    // asset slug => latest data\n    mapping(string => SentimentData) public latestData;\n    \n    // asset slug => historical data (limited to last 30 entries)\n    mapping(string => SentimentData[]) public historicalData;\n    \n    // List of tracked assets\n    string[] public trackedAssets;\n    mapping(string => bool) public isTracked;\n    \n    uint256 public constant MAX_HISTORY = 30;\n    \n    // ============ Events ============\n    \n    event SentimentPublished(\n        string indexed asset,\n        int256 sentiment,\n        uint256 price,\n        uint256 timestamp,\n        string source\n    );\n    \n    event OracleUpdated(address indexed oldOracle, address indexed newOracle);\n    \n    // ============ Modifiers ============\n    \n    modifier onlyOracle() {\n        require(msg.sender == oracle, \"Only oracle can publish\");\n        _;\n    }\n    \n    // ============ Constructor ============\n    \n    constructor() {\n        oracle = msg.sender;\n    }\n    \n    // ============ Oracle Functions ============\n    \n    /**\n     * @notice Publish sentiment data for an asset\n     * @param asset Asset slug (e.g., \"bitcoin\", \"ethereum\")\n     * @param sentiment Sentiment score from Santiment\n     * @param price Price in USD with 18 decimals\n     * @param source Data source identifier\n     */\n    function publishSentiment(\n        string calldata asset,\n        int256 sentiment,\n        uint256 price,\n        string calldata source\n    ) external onlyOracle {\n        SentimentData memory data = SentimentData({\n            timestamp: block.timestamp,\n            sentiment: sentiment,\n            price: price,\n            source: source\n        });\n        \n        // Update latest\n        latestData[asset] = data;\n        \n        // Add to history\n        if (!isTracked[asset]) {\n            trackedAssets.push(asset);\n            isTracked[asset] = true;\n        }\n        \n        // Maintain history limit\n        if (historicalData[asset].length >= MAX_HISTORY) {\n            // Shift array (expensive but simple for demo)\n            for (uint i = 0; i < MAX_HISTORY - 1; i++) {\n                historicalData[asset][i] = historicalData[asset][i + 1];\n            }\n            historicalData[asset][MAX_HISTORY - 1] = data;\n        } else {\n            historicalData[asset].push(data);\n        }\n        \n        emit SentimentPublished(asset, sentiment, price, block.timestamp, source);\n    }\n    \n    /**\n     * @notice Batch publish multiple assets\n     */\n    function publishBatch(\n        string[] calldata assets,\n        int256[] calldata sentiments,\n        uint256[] calldata prices,\n        string calldata source\n    ) external onlyOracle {\n        require(assets.length == sentiments.length && sentiments.length == prices.length, \"Array length mismatch\");\n        \n        for (uint i = 0; i < assets.length; i++) {\n            SentimentData memory data = SentimentData({\n                timestamp: block.timestamp,\n                sentiment: sentiments[i],\n                price: prices[i],\n                source: source\n            });\n            \n            latestData[assets[i]] = data;\n            \n            if (!isTracked[assets[i]]) {\n                trackedAssets.push(assets[i]);\n                isTracked[assets[i]] = true;\n            }\n            \n            // Simplified history for batch\n            if (historicalData[assets[i]].length < MAX_HISTORY) {\n                historicalData[assets[i]].push(data);\n            }\n            \n            emit SentimentPublished(assets[i], sentiments[i], prices[i], block.timestamp, source);\n        }\n    }\n    \n    // ============ View Functions ============\n    \n    /**\n     * @notice Get latest sentiment for an asset\n     */\n    function getLatest(string calldata asset) external view returns (\n        uint256 timestamp,\n        int256 sentiment,\n        uint256 price,\n        string memory source\n    ) {\n        SentimentData memory data = latestData[asset];\n        return (data.timestamp, data.sentiment, data.price, data.source);\n    }\n    \n    /**\n     * @notice Get history length for an asset\n     */\n    function getHistoryLength(string calldata asset) external view returns (uint256) {\n        return historicalData[asset].length;\n    }\n    \n    /**\n     * @notice Get historical data point\n     */\n    function getHistorical(string calldata asset, uint256 index) external view returns (\n        uint256 timestamp,\n        int256 sentiment,\n        uint256 price,\n        string memory source\n    ) {\n        require(index < historicalData[asset].length, \"Index out of bounds\");\n        SentimentData memory data = historicalData[asset][index];\n        return (data.timestamp, data.sentiment, data.price, data.source);\n    }\n    \n    /**\n     * @notice Get count of tracked assets\n     */\n    function getTrackedAssetsCount() external view returns (uint256) {\n        return trackedAssets.length;\n    }\n    \n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Transfer oracle role\n     */\n    function setOracle(address newOracle) external onlyOracle {\n        require(newOracle != address(0), \"Invalid address\");\n        emit OracleUpdated(oracle, newOracle);\n        oracle = newOracle;\n    }\n}\n"
      }
    }
  }
}